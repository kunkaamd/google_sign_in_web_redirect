library google_sign_in_web_redirect;

import 'dart:convert';
import 'dart:js' as js;
import 'dart:html';
import 'package:http/http.dart' as http;
import 'dart:math';
import 'package:flutter/foundation.dart';

const String _kClientIdMetaSelector = 'meta[name=google-signin-client_id]';
const String _kClientIdAttributeName = 'content';

class GoogleSignWeb {
  /// The scope parameter must begin with the openid value and then include the profile value, the email value, or both.
  /// If the profile scope value is present, the ID token might (but is not guaranteed to) include the user's default profile claims.
  /// If the email scope value is present, the ID token includes email and email_verified claims.
  /// In addition to these OpenID-specific scopes, your scope argument can also include other scope values. All scope values must be space-separated. For example, if you wanted per-file access to a user's Google Drive, your scope parameter might be openid profile email https://www.googleapis.com/auth/drive.file.
  /// For information about available scopes, see OAuth 2.0 Scopes for Google APIs or the documentation for the Google API you would like to use.
  final List<String> scopes;

  ///The client ID string that you obtain from the API Console Credentials page, as described in Obtain OAuth 2.0 credentials.
  String? clientId;

  ///Determines where the response is sent. The value of this parameter must exactly match one of the authorized redirect values that you set in the API Console Credentials page (including the HTTP or HTTPS scheme, case, and trailing '/', if any).
  String? redirectUri;

  ///The allowed values are offline and online. The effect is documented in Offline Access; if an access token is being requested, the client does not receive a refresh token unless a value of offline is specified.
  final String accessType;

  ///A random value generated by your app that enables replay protection.
  String? nonce;

  ///	When your app knows which user it is trying to authenticate, it can provide this parameter as a hint to the authentication server. Passing this hint suppresses the account chooser and either pre-fills the email box on the sign-in form, or selects the proper session (if the user is using multiple sign-in), which can help you avoid problems that occur if your app logs in the wrong user account. The value can be either an email address or the sub string, which is equivalent to the user's Google ID.
  final String? loginHint;

  ///	If the value is code, launches a Basic authorization code flow, requiring a POST to the token endpoint to obtain the tokens. If the value is token id_token or id_token token, launches an Implicit flow, requiring the use of JavaScript at the redirect URI to retrieve tokens from the URI #fragment identifier.
  final String responseType;

  ///An opaque string that is round-tripped in the protocol; that is to say, it is returned as a URI parameter in the Basic flow, and in the URI #fragment identifier in the Implicit flow.
  //
  /// The state can be useful for correlating requests and responses. Because your redirect_uri can be guessed, using a state value can increase your assurance that an incoming connection is the result of an authentication request initiated by your app. If you generate a random string or encode the hash of some client state (e.g., a cookie) in this state variable, you can validate the response to additionally ensure that the request and response originated in the same browser. This provides protection against attacks such as cross-site request forgery.
  final String? state;

  ///Streamline the login process for accounts owned by a Google Cloud organization. By including the Google Cloud organization domain (for example, mycollege.edu), you can indicate that the account selection UI should be optimized for accounts at that domain. To optimize for Google Cloud organization accounts generally instead of just one Google Cloud organization domain, set a value of an asterisk (*): hd=*.
  ///
  /// Don't rely on this UI optimization to control who can access your app, as client-side requests can be modified. Be sure to validate that the returned ID token has an hd claim value that matches what you expect (e.g. mycolledge.edu). Unlike the request parameter, the ID token hd claim is contained within a security token from Google, so the value can be trusted.
  final String? hd;

  ///A space-delimited list of string values that specifies whether the authorization server prompts the user for reauthentication and consent. The possible values are:
  /// none
  /// The authorization server does not display any authentication or user consent screens; it will return an error if the user is not already authenticated and has not pre-configured consent for the requested scopes. You can use none to check for existing authentication and/or consent.
  ///
  /// consent
  /// The authorization server prompts the user for consent before returning information to the client.
  ///
  /// select_account
  /// The authorization server prompts the user to select a user account. This allows a user who has multiple accounts at the authorization server to select amongst the multiple accounts that they may have current sessions for.
  ///
  /// If no value is specified and the user has not previously authorized access, then the user is shown a consent screen.
  final String? prompt;

  static GoogleSignWeb? instance;
  static SignInGoogleQueryParameters? _signInGoogleQueryParameters;

  SignInGoogleQueryParameters? get queryParameters {
    return _signInGoogleQueryParameters;
  }

  String? _token;

  set token(String? token) {
    _token = token;
  }

  String? get token {
    return _token ?? _signInGoogleQueryParameters?.idToken;
  }

  static void getQueryParameters() {
    if (kIsWeb) {
      if (Uri.base.hasFragment) {
        _signInGoogleQueryParameters = SignInGoogleQueryParameters(
          idToken: Uri.parse(Uri.base.path + "?" + Uri.base.fragment)
              .queryParameters['id_token'],
        );
      } else if (Uri.base.queryParameters['code'] != null &&
          Uri.base.queryParameters['scope'] != null) {
        _signInGoogleQueryParameters = SignInGoogleQueryParameters(
          code: Uri.base.queryParameters['code'],
        );
      }
    }
  }

  static GoogleSignWeb init(
      {required scopes,
      clientId,
      accessType = "online",
      responseType = "id_token",
      loginHint,
      state,
      nonce,
      redirectUri,
      hd,
      prompt}) {
    instance ??= GoogleSignWeb._(
        scopes: scopes,
        redirectUri: redirectUri,
        accessType: accessType,
        clientId: clientId,
        hd: hd,
        loginHint: loginHint,
        nonce: nonce,
        prompt: prompt,
        responseType: responseType,
        state: state);
    return instance!;
  }

  GoogleSignWeb._(
      {required this.scopes,
      this.clientId,
      this.accessType = "online",
      this.responseType = "id_token",
      this.loginHint,
      this.state,
      this.nonce,
      this.redirectUri,
      this.hd,
      this.prompt}) {
    assert(scopes.isNotEmpty);
    assert(accessType == "offline" || accessType == "online");
    assert(responseType == "code" || responseType == "id_token");
    assert(prompt == null ||
        prompt == "none" ||
        prompt == "consent" ||
        prompt == "select_account");

    redirectUri ??= window.location.href;
    clientId ??= querySelector(_kClientIdMetaSelector)
        ?.getAttribute(_kClientIdAttributeName);
  }

  void signIn() {
    if (kIsWeb) {
      nonce ??= _getNonce;
      final queryParams = {
        "response_type": responseType,
        "client_id": clientId,
        "scope": scopes.join(" "),
        "redirect_uri": redirectUri,
        "access_type": accessType,
        "nonce": nonce,
        "loginHint": loginHint,
        "state": state,
        "hd": hd,
        "prompt": prompt
      };
      final uri =
          Uri.https("accounts.google.com", "/o/oauth2/v2/auth", queryParams);
      js.context.callMethod('open', [uri.toString(), '_self']);
    }
  }

  Future<_GoogleJWT> verifyToken() async {
    try {
      final response = await http.get(
          Uri.parse("https://oauth2.googleapis.com/tokeninfo?id_token=$token"));
      final jwt = _GoogleJWT.fromJson(jsonDecode(response.body));
      if (jwt.verifyIss() == false) {
        throw Exception("Token incorrect");
      }
      if (jwt.aud != clientId) {
        throw Exception("ClientId incorrect");
      }
      if (jwt.checkExpiredDate()) {
        throw Exception("Token expired");
      }
      return jwt;
    } catch (_) {
      throw Exception("Can't verify Token ${_.toString()}");
    }
  }

  String get _getNonce {
    const _chars =
        'AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz1234567890';
    Random _rnd = Random.secure();

    return String.fromCharCodes(Iterable.generate(
        20, (_) => _chars.codeUnitAt(_rnd.nextInt(_chars.length))));
  }
}

class SignInGoogleQueryParameters {
  final String? code;
  final String? idToken;

  SignInGoogleQueryParameters({this.code, this.idToken});
}

class _GoogleJWT {
  final String iss;
  final String aud;
  final String sub;
  final String? email;
  final bool? emailVerified;
  final String? name;
  final String? picture;
  final String? givenName;
  final String exp;

  factory _GoogleJWT.fromJson(Map<String, dynamic> json) {
    return _GoogleJWT(
      iss: json['iss'],
      aud: json['aud'],
      sub: json['sub'],
      email: json['email'],
      emailVerified: json['email_verified'] == "true",
      givenName: json['given_name'],
      name: json['name'],
      picture: json['picture'],
      exp: json['exp'],
    );
  }

  bool checkExpiredDate() {
    final expirationDate = DateTime.fromMillisecondsSinceEpoch(0)
        .add(Duration(seconds: int.parse(exp)));
    return DateTime.now().isAfter(expirationDate);
  }

  bool verifyIss() {
    if (iss == "accounts.google.com" || iss == "https://accounts.google.com") {
      return true;
    }
    return false;
  }

  _GoogleJWT(
      {required this.iss,
      required this.aud,
      required this.sub,
      required this.email,
      required this.emailVerified,
      required this.name,
      required this.picture,
      required this.givenName,
      required this.exp});
}
